William Hilska
CS 445 Final Exam

32.
	a. The fork-and-pull management model is a scheme of facilitating multiple remote developers or development teams on a central code-based repository. Git is an example of a system that uses fork-and-pull to allow for and encourage collaboration. There are two aspects of the fork-and-pull model: forking, and pulling. Forking a repository allows a collaborator to create their own copy of the repository, which can receive their pushes. When a collaborator makes changes to a aspect of the repository on their local machine, the collaborator can push these changes to their own copy of the repository, which was created via the fork mentioned earlier. Now, the pull aspect of the model includes the act of submitting a pull request to the 'master' repository. A pull request is what a collaborator does when they want to merge the changes they made to their own repository to the master code. The owners of the master copy must review this pull request, and decide if they want to merge the collaborator's code with their repository. If they accept, the two repos are merged and the new master repo includes these updates.  
	b. This scheme can be very effective for controlling and facilitating collaboration for public code repos. Git, for instance, allows any collaborator to fork their own copy of the repository. Therefore, any changes they make to the repository can only be made to their own separate copy- unless of course the collaborator submits a pull request that is accepted to merge with the master repository. This scheme should be used for projects that are undertaken by multiple remote collaborators. Since these collaborators are working separately, often times on the exact same problem, their solutions may tend to diverge from the master repo. The separate forks allow collaborators to make their own changes to the code, without interfering with any other collaborator's changes. Pull requests allow multiple collaborators to submit their changes for the same problem, and for the master repo to merge the solution that is best. 
	c. Branches are instances of working code (or commit) that are taken on by different parties and worked on separately. Essentially, each time a repo commits, the commit is a working version of the repo. From a commit, there may be any number of branches. Each branch represents a developer or development team working on a feature, or fixing a bug. There is a master branch which always contains a working version of the code. Once the feature is completed and tested, or the bug is fixed, this feature branch is merged-committed with the master branch, and this becomes the new master branch.  
	d. A crisscross merge occurs when a feature branch merges with the master branch, and another feature branch must merge with the master branch before completing the feature and merging back with the master branch. For instance, say developer X creates a feature branch from the master, and before the developer X can complete their feature, a bug is identified, fixed, and merged with the master. Say also that this bug interferes with the feature developer X is working on. Now, the branch developer X is working on is outdated. Developer X must merge his/her branch with the master branch, to fix this bug. Now, developer X can finish their feature, and merge back with the master branch.
	e. A failed push does not necessarily mean there is a merge conflict between your file and the repo's version. A failed push means that for this file, there are commits in the same file in the origin repo that you have not committed yet. In order for you to push your commits, you first have to merge the commits from the original repo, and then you should be able to push.

38.
	a. The main performance challenge for a SaaS app is performance scalability. In other words, when engineers build a SaaS app their main focus should be making sure new users can be added onto the app quickly and efficiently, while maintaining that their app does not suffer in terms of performance. There are a couple key ways that an engineering team can maintain or improve scalability. One surefire way to increase scalability for a SaaS app is to add more resources, or computing power. A classic SaaS app like Twitter is undoubtedly going to need many more servers than a SaaS app with 100 users. With the evolution of cloud computing, adding servers is easy and cost-effective. Companies like Amazon and IBM offer a pay-as-you-go model for their cloud application services. However, as much as resources and servers are important to the performance of a SaaS app, the design of the app itself must be such that the app can handle many users, and take advantage of increased resources. Many SaaS apps need to be restructured and “renovated” to accommodate their user needs.
	b. PaaS stands for Platform as a Service. Companies like Heroku, Amazon, and IBM offer a curated software stack on which a SaaS can be deployed, while managing much of the scalability and performance concerns on their own end. For a team deploying a SaaS, instead of having to worry about buying (and maintaining) servers, they can deploy their app to the cloud via one of these PaaS environments, and let someone else handle it. For instance, Netflix, the multi-billion dollar streaming content service, has none of their own servers. Instead, Netflix is deployed to Amazon’s cloud services. 
	c. Sometimes, a project may move away from PaaS, usually once it becomes so large that it makes sense to bring operations “in-house”. This may be because it makes financial sense to bring operations in-house as opposed to continuing to use a PaaS, or that the app has so many users that a PaaS cannot provide enough resources for it to run smoothly. Although this does happen, the school of thought in the computing world says that keeping your application in the cloud for as long as possible is the best way to go. In order to keep a SaaS app manageable for PaaS deployment, the code must be designed and redesigned to accommodate increases both in users and resources. For instance, much work must be done with databases, which are very difficult to scale, to ensure that the app can remain in the cloud.
	d. Shrink-wrapped software is developed and released for specific environments, and typically is not updated very often. On the other hand, SaaS applications are required to run on an indeterminate number of environments, and are often updated daily, or even several times a day. For these reasons, release and deployment are more challenging for these cloud-based SaaS applications. There requires more testing and code-tweaking to ensure an update does not break an existing application. 
	e. The principle of least privilege is key to security in computer science. Least privilege means that every aspect of a program- a user, a module, etc. only has the bare minimum privileges required to accomplish necessary tasks. Essentially, if a user does not need to have access to a certain feature of a program, that user is not allowed access to this feature, according to the principle of least privilege. This concept, while it may seem overzealous at times, is essential to tying up loose ends in code, maintaining security, and preventing misuse of code. 
	f. The principle of psychological acceptability, in terms of security, is that security features in code should not add complexity to it that hinders the user experience. Applications and resources should be accessible and easy to use, while security features should be installed behind the scenes.
39. Lessons Learned
	a. Personally I found that learning and understanding the different approaches and phases of software development will be very important to me in the future. Knowing how to program is great, but understanding how a development team operates should serve me well as I graduate from college and enter the workforce.
	b. I saw that there was a JavaScript aspect of the course that we were not able to cover, due to the bulk of material that we had to cover throughout the semester. I am interested in learning JavaScript, and I feel that there are very few if any classes at Binghamton that introduce JavaScript to Computer Science students. It would have been nice if there was time to cover it.
	c. After this class, I do feel like I have a pretty good understanding of Ruby. We covered the features of the Ruby programming language pretty extensively, and I felt that understanding a language, as well as coding with it, is essential.
	d. I personally had a hard time with all of the different tools that we had to use to accomplish the tasks. I felt like PivotalTracker was a little complicated, in terms of creating tasks.

Collaborators: Mark Stepniewski, Ben Malecki (in class)
Reviewers: Omar Hashmi and Mark Stepniewski
https://www.youtube.com/watch?v=_867rr3fejk
