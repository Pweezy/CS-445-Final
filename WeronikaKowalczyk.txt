Question: 7
Owner: Weronika Kowalczyk
Collaborators: Shari, Jojo
Reviewer: Kelsey- I approve of this answer everything looks good!
Hangout: http://youtu.be/Ucl46TncWdk
Pivotal Tracker: https://www.pivotaltracker.com/story/show/84548430 

7.Kent Beck, one of the original signers of the Agile Manifesto, is the founder of Extreme Programming, one of the major versions of Agile process development.
a. Why is it called 'Extreme' programming: how does this relate to the best practices of Plan and Document developments?
b. Describe the (current) thirteen practices of Extreme Programming.
c. Do these practices adequately describe Agile process methodology?
 
a. Why is it called 'Extreme' Programming?
It takes obvious, common sense principles and practices to extreme levels. For example:
-If short iterations are good, make them as short as possible -- hours or minutes or seconds rather than days or weeks or years.
-If simplicity is good, always do the simplest thing that could possibly work.
-If testing is good, test all the time. Write the test code before you write the code to test.
-If code reviews are good, review code continuously, by programming in pairs, two programmers to a computer, taking turns looking over each other's shoulders.
 
The goals of plan and document software development processes are to improve predictability via extensive documentation, which must be changed whenever the goals change. It relates to the practices of the Waterfall lifecycle, where the project is completed in phases, as well as the Spiral model, where the idea is to iterate through a sequence of four phases, with each iteration resulting in a prototype that is a refinement of the previous version. The requirement documents are developed across the iteration as they are needed and evolve with the project. Rational Unified Process (RUP) is a process where each phase involves iteration, and you work with stakeholders to identify use cases, design software architecture, set the development plan, and build an initial prototype.
 
b. Primary Practices:
 
Requirement Analysis and Planning:
 
Stories: the functionalities of the system are described using stories, short descriptions of customer-visible functionalities. Stories also drive system development.
 
Weekly Cycle: software development is performed a week at a time. At the beginning of every week there is a meeting where the stories to develop in the week are chosen by the customer.
 
Quarterly Cycle: on a larger time scale, development is planned a quarter at a time.
This is made up of reflections on the team, the project and the progress.
 
Slack: avoid making promises you cannot fulfill. In any plan, include some tasks that can be dropped if you get behind. In this way, you will keep a security margin, to be used in the case of un-forecasted problems.
 
Team and Human Factors:
 
Sit Together: development teams should work in an open space, able to host the whole team, to maximize communication.
 
Whole Team: the team should be composed of members with all the skills and the perspectives needed for the project to succeed. They must have a strong sense of belonging, and must help each others.
 
Informative Workspace: the workspace should be provided with informative posters and other stuff, giving information on the project status and on the tasks to be performed.
 
Energized Work: developers must be refreshed, so that they can focus on their job and be productive. Consequently, limit overtime working so everyone can spend time for his or her own private life. This practice in the old version of XP was called “sustainable pace”
 
Pair Programming: the code is always written by two programmers at one machine. This practice exists already in the original XP.
 
Design:
 
Incremental Design: XP opposes producing a complete design up front. The development team produces the code as soon as possible in order to obtain feedback and improve the system continuously. Design is indispensable to obtain good code. The question is when to design. XP suggests to do it incrementally during coding. The helpful way to obtain this is to eliminate duplications in the code.
 
Test-First Programming: before updating and adding code, it is necessary to write tests in order to verify the code.
 
Cowboy coding: It is easy to get carried away to program quickly and put everything in mind in the code. If we write tests and you have to run them, the tests help us focus on the problem at hand, and can prove that our design is correct.
 
Coupling and cohesion: if it isn't easy to write a test, this means that you have a problem of design, not of testing or coding. If your code is loosely coupled and highly cohesive, you can test it easily.
 
Trust: if you write code that works and you document it with automated tests, your teammates will trust you.
 
Rhythm: it is easy to get lost and wander for hours when you are coding. If you accustom yourself to the rhythm: test, code, refactor, test, code, refactor, it will not happen.
 
Software Coding and Releasing:
 
Ten-Minute Build: System should be built and all of the tests should be finished in ten minutes, in order to execute it often and obtain feedback.
 
Continuous Integration: Developers should be integrating changes every two hours in order to ease integration headaches.
 
c. Yes, but there are more practices, such as corollary practices that should be considered and are used to describe the agile process in more detail.
 
Question: 8
Owner: Weronika Kowalczyk
Collaborators: Shari and Linn
Reviewer: Kyle - It looks good, the answers are complete.
Hangout: http://youtu.be/Ucl46TncWdk
Pivotal Tracker: https://www.pivotaltracker.com/story/show/84548426 

8. Answer the following questions with respect to the Waterfall, Incremental, RAD, Spiral and Agile process models.
Discuss with respect to ALL aspects of a project that would be considered such as project size, type, duration and technical challenge, team characteristics such as skill level and experience, and client characteristics such as availability, flexibility (or not), sector (private, government, . . .), technical astuteness, etc..
a. What are the major features of the process model?
b. When would you recommend using this process model?
c. When would you NOT recommend using this process model?
 
a. WATERFALL – The long life of software is acknowledged by a maintenance phase that repairs errors as they are discovered. New versions of software go through several phases, and take typically between 6 and 18 months.
 
INCREMENTAL – The product is designed, implemented, and tested incrementally until the product is finished. Applies the waterfall model incrementally.
 
RAD -  Rapid Application Development. It is a type of incremental model. The components or functions are developed in parallel as if they are mini projects. This can quickly give the customer something to see and use and to provide feedback regarding the delivery and their requirements.
 
SPIRAL – Determine objectives and constraints of the iteration, evaluate alternatives and identify and resolve risks, develop and verify the prototype for this iteration, plan the next iteration.
 
AGILE – Emphasizes test driven development, use user stories to reach agreement and validate customer requirements and velocity to measure project progress.
 
b. WATERFALL – When you work for a big client and they enforce a very formal approach – like the government.
 
INCREMENTAL – When you need a flexible model, less costly to change scope and requirements.
 
RAD - When you want to show a product so that the client can decide what other features they want/ what they want to take out, quick initial review occurs.
 
SPIRAL – High amount of risk analysis, good for large and mission-critical projects, additional functionality can be added at a later date.
 
AGILE – When you want feedback from the client, the features aren’t set in stone yet. When new changes are needed to be implemented, the freedom agile gives to change is very important.
 
c. WATERFALL – Once an application is in the testing stage, it is very difficult to go back and change something that was not well-thought out in the concept stage.
 
INCREMENTAL – Needs good planning and design, needs a clear and complete definition of the whole system before it can be broken down and built incrementally. Total cost is higher than waterfall.
 
RAD – Depends on strong team and individual performances for identifying business requirements.
 
SPIRAL - Project’s success is highly dependent on the risk analysis phase, doesn’t work well for smaller projects, can be a costly model.
 
AGILE – In case of some software deliverables, especially the large ones, it is difficult to assess the effort required at the beginning of the software development life cycle, there is lack of emphasis on necessary designing and documentation.
 

Question: 39
Owner: Weronika Kowalczyk

Write your own sections of our Lessons Learned document for the class by summarizing:
a. What were the most important (to you, personally) concepts, principles, skills, tools, etc. that you learned/mastered throughout the semester.
b. Note any concepts, principles, skills, tools, etc. that you would have liked to learn, but that we didn't cover.
c. List all everything that you feel you did especially well this semester (master specific tools, languages, skills, etc.; contribute to the project in a specific way, etc., learn and implement specific things quickly, etc.).
d. List anything that that you feel that you didn't do as well, or that didn't go as well as you hoped (getting a list of these items will help me to better schedule material for future semesters).
e. THANK YOU!

a. Learning about the agile process, as well as the other development models, was the most helpful for me. They were brought up prominently in several job interviews that I had. 
b. I would have liked to learn how to use databases with ruby on rails/heroku.
c. I feel like I have mastered knowledge of the different process models. I also think I mastered cucumber tests and ruby. 
d. I feel like learning ruby on rails was a challenge and hard to pick up. I think the intro homework to ruby on rails should be a bit easier so it’s easier to understand. 

